# TIL - 2025년 7월 30일

## useVideoEffects 훅으로 AI 효과 관리

### 문제 상황

- WaitingRoom과 RecordingRoom에서 동일한 비디오 이펙트 로직 중복
- MediaPipe, 필터, 세그멘테이션 처리가 각 컴포넌트에 흩어져 있음
-

### useVideoEffects.js 구조

```js
const useVideoEffects = ({
  videoElement,
  canvasElement,
  autoStart = true,
  onStateChange = () => {},
}) => {
  const selfieSegmentationRef = useRef(null);
  const [aiLoaded, setAiLoaded] = useState(false);

  const { cameraMode, transparency } = useCameraStore();
  const { selectedFilter } = useVideoEffectsStore();

  // MediaPipe 초기화
  useEffect(() => {
    const initMediaPipe = async () => {
      try {
        const selfieSegmentation = await initializeClientMediaPipe({
          modelSelection: 1,
          selfieMode: true,
        });
        selfieSegmentationRef.current = selfieSegmentation;
        setAiLoaded(true);
      } catch (error) {
        /* console.error("MediaPipe 초기화 실패:", error); */
      }
    };

    initMediaPipe();
  }, []);

  // 비디오 처리 로직
  const processVideo = useCallback(() => {
    if (!videoElement || !canvasElement || !aiLoaded) return;

    const canvas = canvasElement;
    const ctx = canvas.getContext("2d");

    // 세그멘테이션 처리
    if (cameraMode !== 1) {
      // FULL이 아닌 경우
      processSegmentation(ctx, videoElement, cameraMode);
    } else {
      renderOriginalVideo(ctx, videoElement);
    }

    // 필터 적용
    if (selectedFilter) {
      applyFilterToCanvas(ctx, selectedFilter);
    }
  }, [videoElement, canvasElement, aiLoaded, cameraMode, selectedFilter]);

  return {
    aiLoaded,
    processVideo,
    // 기타 필요한 함수들...
  };
};
```

### 배운 점

- 복잡한 AI 처리 로직을 훅으로 분리하여 재사용성 증대
- `useCallback`으로 성능 최적화
- 초기화 상태(`aiLoaded`)로 안전한 처리 보장

## VideoPreview 컴포넌트의 forwardRef 활용

### VideoPreview.jsx의 ref 전달

```jsx
const VideoPreview = forwardRef(
  ({ className = "", showOverlay = true, onEffectsChange = () => {} }, ref) => {
    const canvasRef = useRef(null);
    const { videoRef, currentStream } = useCamera();

    // 부모 컴포넌트에서 접근 가능한 메서드 제공
    useImperativeHandle(ref, () => ({
      getCanvas: () => canvasRef.current,
      getVideoElement: () => videoRef.current,
      startEffects: () => {
        // 이펙트 시작 로직
      },
      stopEffects: () => {
        // 이펙트 정지 로직
      },
    }));

    return (
      <div className={className}>
        <video ref={videoRef} autoPlay muted hidden />
        <canvas ref={canvasRef} />
      </div>
    );
  }
);
```

### 부모에서 사용

```jsx
// RoomInfo.jsx에서
const videoPreviewRef = useRef(null);

const handleSomeAction = () => {
  // VideoPreview의 메서드 호출
  videoPreviewRef.current?.startEffects();
};

return (
  <VideoPreview ref={videoPreviewRef} onEffectsChange={handleEffectsChange} />
);
```

### 배운 점

- `forwardRef`로 자식 컴포넌트의 DOM이나 메서드에 접근 가능
- `useImperativeHandle`로 부모에게 노출할 인터페이스 제어
- 컴포넌트 간 직접적인 제어가 필요할 때 유용
