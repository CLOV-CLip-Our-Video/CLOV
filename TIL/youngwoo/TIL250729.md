# TIL - 2025년 7월 29일

## WebSocket 연결 및 이벤트 처리 구조

### socket.js 서비스 구조

- WebSocket 연결을 전역에서 관리하는 서비스 파일
- 단일 소켓 인스턴스로 중복 연결 방지
-

```js
// socket.js
let socket = null;

export const connectWebSocket = (
  roomCode,
  clientId,
  onMessageCallback,
  onOpenCallback
) => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    /* console.warn("🔁 이미 열린 WebSocket 연결 존재. 재사용"); */
    return;
  }

  const url = `wss://clov.co.kr/ws?roomCode=${roomCode}&clientId=${clientId}`;
  socket = new WebSocket(url);

  socket.onopen = () => {
    /* console.log("✅ WebSocket connected"); */
    onOpenCallback?.();
  };

  socket.onmessage = (event) => {
    const message = JSON.parse(event.data);
    onMessageCallback?.(message);
  };
};

export const sendEvent = (event, data) => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    const payload = { event, data };
    socket.send(JSON.stringify(payload));
  }
};
```

### useSocketEvents 훅으로 이벤트 분기 처리

```js
// useSocketEvents.js
export default function useSocketEvents() {
  const setAll = useCanvasParticipantsStore(
    (s) => s.setAllParticipantsFromSync
  );
  const updateOne = useCanvasParticipantsStore((s) => s.updateParticipantState);

  return function handleSocketMessage(message) {
    const { event, data } = message;

    switch (event) {
      case "user-joined":
        const newParticipants = Object.entries(data.participants).map(
          ([id, nickname]) => ({ clientId: id, nickname, x: 100, y: 100 })
        );
        setAll(newParticipants);
        break;

      case "user-left":
        // 참여자 제거 로직
        break;
    }
  };
}
```

### 배운 점

- WebSocket 연결 상태 체크로 중복 연결 방지
- 이벤트 처리 로직을 별도 훅으로 분리하여 재사용성 향상
- 콜백 함수로 컴포넌트별 처리 로직 분리

## useRoomEntry 훅으로 방 입장 로직 분리

### 기존 문제

- 방 생성/입장 로직이 컴포넌트에 직접 작성되어 있음
- API 호출과 WebSocket 연결이 섞여서 복잡함

### useRoomEntry.js 구조

```js
const useRoomEntry = () => {
  const navigate = useNavigate();
  const [isEntering, setIsEntering] = useState(false);
  const { setRoomCode, setClientId, setIsHost } = useRoomStore();

  const handleEnterRoom = async () => {
    setIsEntering(true);

    try {
      // 1. API 호출로 방 입장
      const response = await joinRoom(roomCode, nickname);

      // 2. 상태 업데이트
      setClientId(response.clientId);
      setIsHost(response.isHost);

      // 3. WebSocket 연결
      connectWebSocket(roomCode, response.clientId, onMessage);

      // 4. 페이지 이동
      navigate(`/recording/${roomCode}`);
    } catch (error) {
      /* console.error("방 입장 실패:", error); */
    } finally {
      setIsEntering(false);
    }
  };

  return { handleEnterRoom, isEntering };
};
```

### 배운 점

- 복잡한 로직을 커스텀 훅으로 분리하면 가독성과 재사용성 향상
- API 호출 → 상태 업데이트 → WebSocket 연결 → 네비게이션 순서 중요
- 로딩 상태 관리로 사용자 경험 개선
