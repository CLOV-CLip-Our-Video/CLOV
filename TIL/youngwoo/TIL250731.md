# TIL - 2025년 7월 31일

## useWebRTC 훅으로 WebRTC 연결 관리

### useWebRTC.js 구조

- PeerConnection 생성 및 관리
- 시그널링 서버를 통한 offer/answer 교환
-

```js
export const useWebRTC = () => {
  const peerConnectionsRef = useRef({});
  const remoteVideoElementsRef = useRef({});
  const { localStream } = useCameraStore();

  const rtcConfig = {
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
    ],
  };

  const createPeerConnection = useCallback(
    async (targetClientId, isInitiator = false) => {
      const peerConnection = new RTCPeerConnection(rtcConfig);

      // 로컬 스트림 추가
      if (localStream) {
        localStream.getTracks().forEach((track) => {
          peerConnection.addTrack(track, localStream);
        });
      }

      // ICE candidate 처리
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          sendEvent("ice-candidate", {
            candidate: event.candidate,
            targetClientId,
          });
        }
      };

      // 원격 스트림 처리
      peerConnection.ontrack = (event) => {
        const remoteStream = event.streams[0];
        // 원격 비디오 엘리먼트에 연결
      };

      peerConnectionsRef.current[targetClientId] = peerConnection;
      return peerConnection;
    },
    [localStream, clientId]
  );

  return {
    createPeerConnection,
    handleOffer,
    handleAnswer,
    handleIceCandidate,
    // ...
  };
};
```

### RecordingCanvas에서 WebRTC 사용

```jsx
const RecordingCanvas = () => {
  const {
    handleOffer,
    handleAnswer,
    handleIceCandidate,
    peerConnectionsRef,
    remoteVideoElements,
  } = useWebRTC();

  // WebSocket 메시지 처리
  useEffect(() => {
    const handleWebRTCMessage = (message) => {
      switch (message.event) {
        case "offer":
          handleOffer(message.data);
          break;
        case "answer":
          handleAnswer(message.data);
          break;
        case "ice-candidate":
          handleIceCandidate(message.data);
          break;
      }
    };

    // WebSocket 이벤트 리스너 등록
  }, []);
};
```

### 배운 점

- WebRTC 로직을 훅으로 분리하여 재사용성 향상
- PeerConnection을 ref로 관리하여 컴포넌트 리렌더링과 분리
- STUN 서버 설정으로 NAT 환경에서도 연결 가능

## useParams 활용한 라우팅 파라미터 처리

### WaitingRoom에서 roomCode 받기

```jsx
// WaitingRoom.jsx
const WaitingRoom = () => {
  const { roomId } = useParams(); // URL에서 파라미터 추출
  const roomCode = useRoomStore((state) => state.roomCode);
  const setRoomCodeState = useRoomStore((s) => s.setRoomCode);

  useEffect(() => {
    if (roomId && roomId !== roomCode) {
      setRoomCodeState(roomId); // 전역 상태 동기화
    }
  }, [roomId, roomCode, setRoomCodeState]);

  return <div>{/* 컴포넌트 내용 */}</div>;
};
```

### App.jsx 라우팅 설정

```jsx
<Routes>
  <Route path="/waiting/:roomId" element={<WaitingRoom />} />
  <Route path="/recording/:roomId" element={<RecordingRoom />} />
</Routes>
```

### 배운 점

- `useParams()`로 URL 파라미터를 간단히 추출 가능
- 라우팅 파라미터와 전역 상태를 동기화하여 일관성 유지
- 페이지 새로고침 시에도 roomId 정보 유지 가능
