# TIL 250722

## 오늘 한 일 : 프로젝트 관련
- Canvas 상태 동기화 구조 개편 ㅠㅠ
    - 기존 PUT /canvas/partial API는 WebSocket 구조로 대체되며 사용하지 않게 되었음
    - 이유: 실시간 상태 업데이트를 REST로 처리하면 지연·충돌 문제가 발생할 수 있기 때문
    - 현재는 클라이언트가 WebSocket으로 이벤트를 보내면, 서버는 이를 Redis에 저장하고, 동시에 Pub/Sub으로 브로드캐스트함
    - 코드 정리가 덜 돼서 오늘 커밋 못해서 내일 할 예정
- WebSocket 이벤트 흐름 정리
- 팀원에게 Redis 구조 및 WebSocket 연동 방식 설명
    - 현석오빠한테 질문 받은거
        - 웹소켓 엔드포인트 
        - 이벤트 구조 정리 -> 방 입장, 위치 조정, 카메라 촬영 시작, 방 나가기
        - 방 코드는 FE, BE 중에서 어디서 생성하나? -> 백엔드에서
        - clientId 는 프론트에서 UUID로 생성하나? -> 백엔드에서
        - 호스트 권한은 방 생성자가 자동으로 가지면 되나? -> 백엔드에서 isHost: "true"로
        - Spring WebSocket vs Netty-SocketIO 중 어떤게 더 편해? 라이브러리 질문임 -> Spring WebSocket로 현재 코드짬
        - 방 정보가 Redis에 있나? -> yes
        - canvas 상태 관리 동작 흐름 -> 1. 처음 방 생성/입장, 2. 실시간 동기화 관점에서 설명
- 예린이 코드 리뷰해주다가 현재 방 관련 api들이 rdb위주로 짜여진 것에 대한 논의
    - 방 나가기같은 경우 -> redis에서 관련 정보 싹 지워줘야함
    - 방 생성 시 -> clientId, nickname은 rdb에 저장안하고 현재 redis에(clientId: nickname)이런 형태로 저장하는데, redis에 저장된 구조를 살짝 바꿔서 방코드 별로 관리하는걸로 바꾸기
        - 구조를 쉽게 설명하기위해 Redis 키 구조를 예시 형태로 보여주며 설명함
        - 이렇게해야 방 나가거나 하는 경우 관리 잘 될 것..!


## 오늘 배운 것, 고민
### REST 방식의 Canvas 상태 API가 부적절했던 이유
- PUT /canvas/partial API는 참여자 위치를 업데이트하기 위한 REST 방식이었으나,실시간성이 필요한 시스템에서 적합하지 않았음
- REST 방식은 클라이언트 타이밍에 따라 중복 호출, 데이터 충돌, 렌더링 지연 등의 문제 발생
- WebSocket으로 구조를 전환함으로써:
    - 클라이언트는 상태만 보내면 되고
    - 서버는 Redis에 저장 + Pub/Sub 브로드캐스트로 다중 사용자 동기화 처리 가능
- 아래와 같은 구조로 변경!
```
[클라이언트 움직임 발생]
   ↓
[WebSocket.send() 호출로 서버에 상태 전송]
   ↓
[CanvasWebSocketHandler → Redis 저장 → 다른 클라이언트에게 WebSocket 브로드캐스트]
```
### GET /canvas API의 필요성과 대체 방안
- GET /canvas는 최초 방 입장 시 배경/위치 정보를 받아오기 위해 설계되었으나, 실제로는 POST /room, POST /room/join 시점에 함께 반환하는 게 효율적임
- REST 호출을 하나 줄이고, 프론트에서는 별도 API 호출 없이 바로 렌더링 가능
- 내일 리팩터링 예정: GET /canvas API 제거, 방생성/참여 api 수정
- 방 생성/참여 응답에 background, participantStates 포함

### WebSocket에서 null 값 상태가 먼저 수신되는 문제
- 이건 내 잘못...코드를 잘못 짰는데 한참 어디를 잘못 짠지 몰라서..고생함...ㅠㅠ 별거 아니였는데..

### 캔버스 상태 동기화 WebSocket 총 정리
- 프론트는 new WebSocket("ws://localhost:8080/ws/canvas?roomCode=...&clientId=...")로 WebSocket 연결
- 연결되면 CanvasWebSocketHandler.afterConnectionEstablished()가 호출됨
- socket.send(JSON.stringify({ roomCode, clientId, x, y, scale, opacity }))로 메시지 전송 시
    - handleTextMessage()에서 수신한 payload를 RedisPublisher가 "canvas" 채널로 그대로 발행
- RedisSubscriber는 RedisPubSubConfig 설정에 의해 "canvas" 채널을 구독 중이며
    - 수신 메시지를 로그로 출력하는 onMessage() 로직이 동작
- "canvas"라는 채널 이름은 @Bean ChannelTopic canvasTopic() 메서드에서 정의되고
- Spring이 자동으로 redisContainer()의 파라미터에 주입해 설정됨

## 내일 할 일
- Redis Pub/Sub 채널 구조를 "canvas" 단일 채널에서 "canvas:{roomCode}" 형식의 방별 채널 구조로 확장
    - 메시지를 발행할 때 채널명을 canvas:{roomCode}로 지정하고 RedisSubscriber가 해당 채널만 구독하여 불필요한 메시지 수신을 방지할 수 있도록 구조 개선 예정
- 기존 `GET /canvas` API는 제거하고, 방 생성/참여 시 캔버스 상태(배경 + 참여자 위치)를 응답에 포함하는 구조로 리팩터링
- - WebSocket 메시지 송/수신 시 `"event"` 필드를 기준으로 분기 처리 로직 구현 예정  
    - 예: "join-room", "update-position", "start-recording", "leave-room"...
    - event 필드명은 프론트랑 상의한 내용 기반으로 작성할 예정
- 생각보다...간단한데 헷갈려서 오늘 오래걸렸는데 내일 웹소켓은 마무리 짓고 ci/cd 백엔드끼리 같이 해보기로함!
