package com.clov.backend.domain.room.service;

import com.clov.backend.common.enums.RoomStatus;
import com.clov.backend.common.exception.CustomException;
import com.clov.backend.common.metrics.RealTimeWebRTCMetrics;
import com.clov.backend.common.metrics.RoomDistributionMetrics;
import com.clov.backend.common.redis.repository.RedisRepository;
import com.clov.backend.common.response.ErrorCode;
import com.clov.backend.common.util.RandomUtil;
import com.clov.backend.domain.background.entity.Background;
import com.clov.backend.domain.background.repository.BackgroundRepository;
import com.clov.backend.domain.canvas.dto.CanvasStateDto;
import com.clov.backend.domain.participant.dto.request.ParticipantRequestDto;
import com.clov.backend.domain.participant.dto.response.ParticipantResponseDto;
import com.clov.backend.domain.participant.entity.Participant;
import com.clov.backend.domain.participant.repository.ParticipantRepository;
import com.clov.backend.domain.participant.service.ParticipantService;
import com.clov.backend.domain.room.dto.request.RoomCreateRequestDto;
import com.clov.backend.domain.room.dto.request.RoomHostUpdateRequestDto;
import com.clov.backend.domain.room.dto.response.RoomCreateResponseDto;
import com.clov.backend.domain.room.dto.response.RoomLeftResponseDto;
import com.clov.backend.domain.room.dto.response.RoomParticipantResponseDto;
import com.clov.backend.domain.room.entity.Room;
import com.clov.backend.domain.room.repository.RoomRepository;
import com.vane.badwordfiltering.BadWordFiltering;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class RoomService {

    private static final String SITE_URL = "https://clov.co.kr/";
    private static final int MAX_PARTICIPANTS = 10;

    private final RealTimeWebRTCMetrics realTimeMetrics;
    private final RoomDistributionMetrics distributionMetrics;
    private final RoomRepository roomRepository;
    private final RedisRepository redisRepository;
    private final ParticipantService participantService;
    private final ParticipantRepository participantRepository;
    private final BackgroundRepository backgroundRepository;

    public RoomCreateResponseDto createRoom(RoomCreateRequestDto roomCreateRequestDto) {
        BadWordFiltering badWordFiltering = new BadWordFiltering();
        ClassPathResource resource = new ClassPathResource("badwords.txt");
        try (InputStream inputStream = resource.getInputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))){

           List<String> words = reader.lines()
                   .flatMap(line -> Arrays.stream(line.split(",")))
                   .map(String::trim)
                   .filter(word -> !word.isEmpty())
                   .collect(Collectors.toList());

           badWordFiltering.addAll(words);

        } catch (IOException e){
            e.printStackTrace();
        }

        if(badWordFiltering.check(roomCreateRequestDto.getNickname())) {
            throw new CustomException(ErrorCode.BAD_WORD_NICKNAME);
        }

        Room room = Room.builder()
                .roomCode(RandomUtil.generateCode())
                .status(RoomStatus.OPEN)
                .createdAt(OffsetDateTime.now())
                .build();
        roomRepository.save(room);

        //Î∞© ÏΩîÎìúÏùò Ïú†Ìö®ÏãúÍ∞Ñ ÏÑ§Ï†ï
        long expireSeconds = 60 * 60; //1ÏãúÍ∞ÑÏúºÎ°ú ÏùºÏãú ÏàòÏ†ï

        UUID hostId = participantService.createParticipantAsHost(room.getRoomCode(), roomCreateRequestDto);

        // Ï¥àÍ∏∞ Ï∫îÎ≤ÑÏä§ ÏÉÅÌÉú Ï§ÄÎπÑ
        CanvasStateDto initialState = CanvasStateDto.builder()
                .x(200)
                .y(100)
                .scale(1D)
                .opacity(1D)
                .build();
//        //redisÏóê RoomTTL ÏÑ§Ï†ï
//        redisRepository.setRoomTTL(room.getRoomCode(), expireSeconds);
//
//        //redisÏóê hostId Ï†ÄÏû•
//        redisRepository.saveHost(room.getRoomCode(), hostId);
//
//        //redisÏóê ÎãâÎÑ§ÏûÑ Ï†ÄÏû•
//        redisRepository.saveNickname(room.getRoomCode(), hostId, roomCreateRequestDto.getNickname());
//
//        //redisÏóê state Ï†ÄÏû•
//        redisRepository.saveCanvasState(room.getRoomCode(), hostId, CanvasStateDto.builder()
//                .x(200)
//                .y(100)
//                .scale(1D)
//                .opacity(1D)
//                .build());

        // Î∞∞Í≤Ω Ï†ïÎ≥¥ Ï§ÄÎπÑ
        Background background = backgroundRepository.findById(1L)
                .orElseThrow(() -> new CustomException(ErrorCode.ROOM_NOT_FOUND));
        CanvasStateDto.BackgroundDto backgroundDto = CanvasStateDto.BackgroundDto.builder()
                .backgroundUrl(background.getBackgroundUrl())
                .backgroundTitle(background.getBackgroundTitle())
                .build();
//        //redisÏóê background Ï†ÄÏû•
//        redisRepository.saveBackground(room.getRoomCode(), CanvasStateDto.BackgroundDto.builder()
//                .backgroundUrl(background.getBackgroundUrl())
//                .backgroundTitle(background.getBackgroundTitle())
//                .build());

        // üîπ Î∞∞Ïπò Ï≤òÎ¶¨Î°ú Redis ÏûëÏóÖ Ìïú Î≤àÏóê ÏàòÌñâ
//        long expireSeconds = 60 * 30; // 30Î∂Ñ
        redisRepository.batchCreateRoom(
                room.getRoomCode(),
                hostId,
                roomCreateRequestDto.getNickname(),
                initialState,
                backgroundDto,
                expireSeconds
        );

        //metrics ÏÉùÏÑ±
        realTimeMetrics.onRoomCreated(room.getRoomCode());
        realTimeMetrics.onUserJoinedRoom(room.getRoomCode(), hostId.toString());
        realTimeMetrics.onUserOnline(hostId.toString()); // üîπ [Ï∂îÍ∞Ä] Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä
        distributionMetrics.onRoomParticipantCountChanged(room.getRoomCode(), 0, 1);

        log.info("Î∞© ÏÉùÏÑ± ÏôÑÎ£å: roomCode={}, hostId={}, ÌòÑÏû¨ ÌôúÏÑ±Î∞©={}, Ï¥ùÏ∞∏Í∞ÄÏûê={}, Ïò®ÎùºÏù∏={}",
                room.getRoomCode(), hostId,
                realTimeMetrics.getActiveRoomsCount(), realTimeMetrics.getTotalClientsCount(),
                realTimeMetrics.getOnlineUsersCount()); // üîπ [Ï∂îÍ∞Ä] Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ïàò

        return RoomCreateResponseDto.builder()
                .roomCode(room.getRoomCode())
                .joinUrl(SITE_URL + "room/" + room.getRoomCode())
                .hostId(hostId)
                .createdAt(room.getCreatedAt())
                .isHost(true)
                .build();
    }

    public ParticipantResponseDto enterRoom(String roomCode, ParticipantRequestDto participantRequestDto) {
        //Î∞© ÏΩîÎìú ÎßåÎ£å Ïãú ÏûÖÏû• Î∂àÍ∞Ä
        if (!redisRepository.existsRoom(roomCode)) {
            throw new CustomException(ErrorCode.ROOM_CODE_EXPIRED);
        }
        int participantCountBefore = redisRepository.getParticipantCount(roomCode);
        Room room = roomRepository.findByRoomCode(roomCode)
                .orElseThrow(() -> new CustomException(ErrorCode.ROOM_NOT_FOUND));
        UUID clientId = participantService.createParticipant(roomCode, participantRequestDto);

        //Î∞© Ïù∏Ïõê Ï≤¥ÌÅ¨
        if (participantCountBefore >= MAX_PARTICIPANTS) {
            throw new CustomException(ErrorCode.MAX_PARTICIPANTS);
        }

        BadWordFiltering badWordFiltering = new BadWordFiltering();
        ClassPathResource resource = new ClassPathResource("badwords.txt");
        try (InputStream inputStream = resource.getInputStream();
             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))){

            List<String> words = reader.lines()
                    .flatMap(line -> Arrays.stream(line.split(",")))
                    .map(String::trim)
                    .filter(word -> !word.isEmpty())
                    .collect(Collectors.toList());

            badWordFiltering.addAll(words);

        } catch (IOException e){
            e.printStackTrace();
        }

        if(badWordFiltering.check(participantRequestDto.getNickname())) {
            throw new CustomException(ErrorCode.BAD_WORD_NICKNAME);
        }
//        //redisÏóê ÎãâÎÑ§ÏûÑ Ï†ÄÏû•
//        redisRepository.saveNickname(room.getRoomCode(), clientId, participantRequestDto.getNickname());
//
//        //redisÏóê state Ï†ÄÏû•
//        redisRepository.saveCanvasState(room.getRoomCode(), clientId, CanvasStateDto.builder()
//                .x(200)
//                .y(100)
//                .scale(1D)
//                .opacity(1D)
//                .build());

        // Ï¥àÍ∏∞ Ï∫îÎ≤ÑÏä§ ÏÉÅÌÉú Ï§ÄÎπÑ
        CanvasStateDto initialState = CanvasStateDto.builder()
                .x(200)
                .y(100)
                .scale(1D)
                .opacity(1D)
                .build();

        // Î∞∞Ïπò Ï≤òÎ¶¨Î°ú Redis ÏûëÏóÖ Ìïú Î≤àÏóê ÏàòÌñâ
        redisRepository.batchEnterRoom(
                roomCode,
                clientId,
                participantRequestDto.getNickname(),
                initialState
        );

        //Î∞© Ï∞∏Í∞ÄÏûÖÏû• - metric ÏóÖÎç∞Ïù¥Ìä∏
        realTimeMetrics.onUserJoinedRoom(roomCode, clientId.toString());
        realTimeMetrics.onUserOnline(clientId.toString()); // üîπ [Ï∂îÍ∞Ä] Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä

        // üîπ [ÏàòÏ†ï] Ïã§Ï†ú Ï∞∏Í∞ÄÏûê Ïàò Îã§Ïãú ÌôïÏù∏ (Redis Í∏∞Ï§Ä)
        int participantCountAfter = redisRepository.getParticipantCount(roomCode);
        log.info("Î∞© ÏûÖÏû• ÏôÑÎ£å: roomCode={}, clientId={}, Ï∞∏Í∞ÄÏûêÏàò {}->={}, Ï¥ùÏ∞∏Í∞ÄÏûê={}, Ïò®ÎùºÏù∏={}",
                roomCode, clientId, participantCountBefore, participantCountAfter,
                realTimeMetrics.getTotalClientsCount(), realTimeMetrics.getOnlineUsersCount());

        distributionMetrics.onRoomParticipantCountChanged(roomCode, participantCountBefore, participantCountAfter);

        return ParticipantResponseDto.builder()
                .roomCode(roomCode)
                .clientId(clientId)
                .joinedAt(OffsetDateTime.now())
                .isHost(false)
                .build();
    }

    public RoomLeftResponseDto leaveRoom(String roomCode, UUID clientId) {
        Participant participant = participantRepository.findByClientId(clientId);
        Room room = roomRepository.findByRoomCode(roomCode)
                .orElseThrow(() -> new CustomException(ErrorCode.ROOM_NOT_FOUND));

        // üîπ [ÏàòÏ†ï] RedisÏóêÏÑú ÌòÑÏû¨ Ï∞∏Í∞ÄÏûê Ïàò Ï†ïÌôïÌûà Ï°∞Ìöå
        int participantCountBefore = redisRepository.getParticipantCount(roomCode);

        if (participant.getIsHost()) {
            // üîπ [ÏàòÏ†ï] RedisÏóê ÏûàÎçò Î™®Îì† Ï∞∏Í∞ÄÏûêÎì§Ïùò Ìá¥Ïû• Ï≤òÎ¶¨Î•º Î®ºÏ†Ä
            List<String> participants = redisRepository.getParticipants(roomCode);
            for (String participantId : participants) {
                realTimeMetrics.onUserLeftRoom(roomCode, participantId);
                realTimeMetrics.onUserOffline(participantId); // üîπ [Ï∂îÍ∞Ä] Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
            }

            //Ìò∏Ïä§Ìä∏Í∞Ä ÎÇòÍ∞ÄÎäî Í≤ΩÏö∞ Î∞© Í¥ÄÎ†® Redis Îç∞Ïù¥ÌÑ∞ Ï†úÍ±∞
            redisRepository.deleteRoom(roomCode);
            //Î∞© ÌèêÏáÑ
            room.setStatus(RoomStatus.CLOSED);

            // closed at Í∞±Ïã†
            room.setClosedAt(OffsetDateTime.now());

            realTimeMetrics.onRoomDeleted(roomCode);
            // üîπ Î∂ÑÌè¨ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏: Î™®Îì† Ï∞∏Í∞ÄÏûê Ìá¥Ïû•ÏúºÎ°ú Î∞© ÏÜåÎ©∏
            distributionMetrics.onRoomParticipantCountChanged(roomCode, participantCountBefore, 0);

            // üîπ [ÏàòÏ†ï] Î°úÍ∑∏Ïóê Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ïàò Ï∂îÍ∞Ä
            //log.info("Î∞© ÌèêÏáÑ ÏôÑÎ£å: roomCode={}, Ìá¥Ïû•Ï∞∏Í∞ÄÏûêÏàò={}, ÌòÑÏû¨ ÌôúÏÑ±Î∞©={}, Ï¥ùÏ∞∏Í∞ÄÏûê={}, Ïò®ÎùºÏù∏={}",
            //        roomCode, participantCountBefore,
           //         realTimeMetrics.getActiveRoomsCount(), realTimeMetrics.getTotalClientsCount(),
           //         realTimeMetrics.getOnlineUsersCount()); // üîπ [Ï∂îÍ∞Ä] Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ïàò

        } else {
            //ÏùºÎ∞ò Ï∞∏Ïó¨ÏûêÏùò Í≤ΩÏö∞ Ìï¥Îãπ Ï∞∏Í∞ÄÏûêÏùò state ÏÇ≠Ï†ú
            redisRepository.deleteCanvasState(roomCode, clientId);

            // üîπ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏: ÏùºÎ∞ò Ï∞∏Í∞ÄÏûê Ìá¥Ïû•
            realTimeMetrics.onUserLeftRoom(roomCode, clientId.toString());
            realTimeMetrics.onUserOffline(clientId.toString()); // üîπ [Ï∂îÍ∞Ä] Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨

            // üîπ Î∂ÑÌè¨ Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏: 1Î™Ö Í∞êÏÜå
            distributionMetrics.onRoomParticipantCountChanged(roomCode, participantCountBefore, participantCountBefore - 1);

            // üîπ [ÏàòÏ†ï] Î°úÍ∑∏Ïóê Ïò®ÎùºÏù∏ ÏÇ¨Ïö©Ïûê Ïàò Ï∂îÍ∞Ä
            //log.info("Ï∞∏Í∞ÄÏûê Ìá¥Ïû• ÏôÑÎ£å: roomCode={}, clientId={}, Ï∞∏Í∞ÄÏûêÏàò {}->={}, Ï¥ùÏ∞∏Í∞ÄÏûê={}, Ïò®ÎùºÏù∏={}",
             //       roomCode, clientId, participantCountBefore, participantCountBefore - 1,
             //       realTimeMetrics.getTotalClientsCount(), realTimeMetrics.getOnlineUsersCount());
        }
        OffsetDateTime leftAt = OffsetDateTime.now();
        participant.updateLeftAt(leftAt);
        return RoomLeftResponseDto.builder()
                .clientId(clientId)
                .leftAt(leftAt)
                .build();
    }

    public List<RoomParticipantResponseDto> getRoomParticipants(String roomCode) {
        Room room = roomRepository.findByRoomCode(roomCode)
                .orElseThrow(() -> new CustomException(ErrorCode.ROOM_NOT_FOUND));
        List<Participant> participantList = participantRepository.findByRoom(room);

        return participantList.stream()
                .map(participant -> RoomParticipantResponseDto.builder()
                        .clientId(participant.getClientId())
                        .nickname(redisRepository.getNickname(roomCode, participant.getClientId()))
                        .isHost(participant.getIsHost())
                        .build()
                ).collect(Collectors.toList());
    }

    public void checkRoom(String roomCode) {
        //Î∞© ÏΩîÎìú ÎßåÎ£å Ïó¨Î∂Ä Í≤ÄÏÇ¨
        if (!redisRepository.existsRoom(roomCode)) {
            throw new CustomException(ErrorCode.ROOM_NOT_FOUND);
        }
        //Ìï¥Îãπ ÏΩîÎìúÎ•º Í∞ÄÏßÑ Î∞©Ïù¥ ÏûàÎäîÏßÄ Í≤ÄÏÇ¨
        Room room = roomRepository.findByRoomCode(roomCode)
                .orElseThrow(() -> new CustomException(ErrorCode.ROOM_NOT_FOUND));
        //Î∞© ÏÉÅÌÉúÍ∞Ä Îã´ÌòÄÏûàÎäî ÏßÄ Í≤ÄÏÇ¨
        if (room.getStatus().equals(RoomStatus.CLOSED)) {
            throw new CustomException(ErrorCode.ROOM_NOT_FOUND);
        }
    }

    public void changeHost(String roomCode, RoomHostUpdateRequestDto roomHostUpdateRequestDto) {
        //Í∏∞Ï°¥ HostÏùò Í∂åÌïú Í≤ÄÏÇ¨
        Participant hostParticipant = participantRepository.findByClientId(roomHostUpdateRequestDto.getPreviousHostId());
        if(!hostParticipant.getIsHost()) {
            throw new CustomException(ErrorCode.NOT_HOST);
        }

        //Í∏∞Ï°¥ Host Í∂åÌïú ÏÇ≠Ï†ú
        hostParticipant.setIsHost(false);
        participantRepository.save(hostParticipant);

        //ÏÉàÎ°úÏö¥ HostÎ°ú Î≥ÄÍ≤Ω
        Participant participant = participantRepository.findByClientId(roomHostUpdateRequestDto.getNewHostId());
        participant.setIsHost(true);
        participantRepository.save(participant);
        redisRepository.saveHost(roomCode, participant.getClientId());
    }
}
