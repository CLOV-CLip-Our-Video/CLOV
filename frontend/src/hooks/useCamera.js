// frontend/src/hooks/useCamera.js
/* eslint-disable */
import { useEffect, useRef, useState, useCallback } from 'react';
import useCameraStore from '../stores/cameraStore';
import { useDeviceSettings } from './useDeviceSettings';
import useMediaPermissions from './useMediaPermissions';

/**
 * useCamera - Ïπ¥Î©îÎùº Î∞è ÎßàÏù¥ÌÅ¨ Ïä§Ìä∏Î¶º ÏÉùÏÑ± Ï†ÑÏö© ÌõÖ + ÌïòÎìúÌÜ†Í∏Ä Í∏∞Îä• Ìè¨Ìï®
 * Ïπ¥Î©îÎùº ÏûÖÎ†• Ïû•Ïπò Î≥ÄÍ≤Ω Í∏∞Îä• Ï†úÍ±∞, ÎßàÏù¥ÌÅ¨ ÏûÖÎ†• Ïû•Ïπò Î≥ÄÍ≤ΩÏùÄ Ïú†ÏßÄ
 * @param {Object} options - ÏÑ§Ï†ï Í∞ùÏ≤¥
 * @param {boolean} options.autoStart - ÎßàÏö¥Ìä∏ Ïãú ÏûêÎèô ÏãúÏûë Ïó¨Î∂Ä
 * @param {boolean} options.defaultMicOn - Ï¥àÍ∏∞ ÎßàÏù¥ÌÅ¨ ÏÉÅÌÉú
 * @param {boolean} options.showDeviceSettings - ÎîîÎ∞îÏù¥Ïä§ ÏÑ§Ï†ï ÌëúÏãú (ÏÇ¨Ïö© ÏïàÌï®)
 */
export default function useCamera({
  autoStart = false,
  defaultMicOn = false,
  showDeviceSettings = false, // ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
} = {}) {
  const videoRef = useRef(null);
  const streamRef = useRef(null);
  const [isLoading, setIsLoading] = useState(false);
  const [currentStream, setCurrentStream] = useState(null);
  const [streamError, setStreamError] = useState(null);
  const [autoStartCompleted, setAutoStartCompleted] = useState(false);
  const initializingRef = useRef(false);
  const permissions = useMediaPermissions();

  const {
    setLocalStream,
    setVideoEnabled,
    setAudioEnabled,
    isVideoEnabled,
    isAudioEnabled,
  } = useCameraStore();

  // ÎîîÎ∞îÏù¥Ïä§ ÏÑ§Ï†ï ÌõÖ - ÎßàÏù¥ÌÅ¨ ÏûÖÎ†•Í≥º Ïò§ÎîîÏò§ Ï∂úÎ†• ÏßÄÏõê
  const {
    devices,
    selectedDevices,
    isLoading: devicesLoading,
    error: deviceError,
    support,
    refreshDevices,
    changeDevice,
    registerAudioElement,
    selectAudioDevice,
    selectOutputDevice,
    hasAudioDevices,
    getCurrentDeviceInfo,
  } = useDeviceSettings({
    autoSave: false,
    detectChanges: false,
  });

  /**
   * üîß Í∞úÏÑ†Îêú Í∏∞Î≥∏ Ïπ¥Î©îÎùº ÏãúÏûë Ìï®Ïàò - ÎîîÎ∞îÏù¥Ïä§ ID ÏóÜÏù¥ Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏãúÏûë
   */
  const startCamera = useCallback(
    async (deviceOptions = {}) => {
      if (isLoading || initializingRef.current) {
        return;
      }

      try {
        initializingRef.current = true;
        setIsLoading(true);
        setStreamError(null);

        const { video = true, audio = true } = deviceOptions;

        // Í∏∞Î≥∏ getUserMedia ÏÇ¨Ïö© (ÎîîÎ∞îÏù¥Ïä§ ID ÏßÄÏ†ï ÏóÜÏùå)
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: audio
            ? {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              }
            : false,
        });

        // ÎßàÏù¥ÌÅ¨ Ï¥àÍ∏∞ ÏÑ§Ï†ï
        if (audio && stream.getAudioTracks().length > 0) {
          stream.getAudioTracks().forEach((track) => {
            track.enabled = defaultMicOn;
          });
        }

        setCurrentStream(stream);
        streamRef.current = stream;
        setLocalStream(stream);
        setVideoEnabled(video && stream.getVideoTracks().length > 0);
        setAudioEnabled(
          defaultMicOn && audio && stream.getAudioTracks().length > 0
        );
      } catch (err) {
        // console.error('‚ùå Í∏∞Î≥∏ Ïπ¥Î©îÎùº ÏãúÏûë Ïã§Ìå®:', err);
        setStreamError(err.message);

        if (err.name === 'NotAllowedError') {
          // alert('Ïπ¥Î©îÎùº Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
          // console.log(
          //   'Ïπ¥Î©îÎùº Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.'
          // );
        } else if (err.name === 'NotFoundError') {
          // console.log(
          //   'Ïπ¥Î©îÎùºÎÇò ÎßàÏù¥ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÎîîÎ∞îÏù¥Ïä§ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.'
          // );
        } else {
          // console.log(`Ïπ¥Î©îÎùº Ï†ëÍ∑º Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${err.message}`);
        }

        throw err;
      } finally {
        setIsLoading(false);
        initializingRef.current = false;
      }
    },
    [isLoading, defaultMicOn, setLocalStream, setVideoEnabled, setAudioEnabled]
  );

  /**
   * ÌäπÏ†ï ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§Î°ú Ïπ¥Î©îÎùº ÏãúÏûë (ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§ Î≥ÄÍ≤ΩÏö©)
   */
  const startCameraWithAudioDevice = useCallback(
    async (deviceOptions = {}) => {
      if (isLoading || initializingRef.current) return;

      try {
        initializingRef.current = true;
        setIsLoading(true);
        setStreamError(null);

        const {
          audioDeviceId = selectedDevices.audioInput,
          video = true,
          audio = true,
        } = deviceOptions;

        const constraints = {};

        // ÎπÑÎîîÏò§Îäî Ìï≠ÏÉÅ Í∏∞Î≥∏ ÎîîÎ∞îÏù¥Ïä§
        if (video) {
          constraints.video = {
            width: { ideal: 1280, max: 1920 },
            height: { ideal: 720, max: 1080 },
            frameRate: { ideal: 30, max: 60 },
          };
        }

        // Ïò§ÎîîÏò§Îäî ÌäπÏ†ï ÎîîÎ∞îÏù¥Ïä§ ÎòêÎäî Í∏∞Î≥∏ ÎîîÎ∞îÏù¥Ïä§
        if (audio) {
          constraints.audio = audioDeviceId
            ? {
                deviceId: { exact: audioDeviceId },
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 48000,
                channelCount: 1,
                latency: 0.01,
                volume: 0.8,
                // Í≥†Í∏â ÎÖ∏Ïù¥Ï¶à Ï≤òÎ¶¨
                googEchoCancellation: true,
                googNoiseSuppression: true,
                googAutoGainControl: true,
                googHighpassFilter: true,
                googTypingNoiseDetection: true,
                googNoiseReduction: true,
              }
            : {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 48000,
                channelCount: 1,
                latency: 0.01,
                volume: 0.8,
                // Í≥†Í∏â ÎÖ∏Ïù¥Ï¶à Ï≤òÎ¶¨
                googEchoCancellation: true,
                googNoiseSuppression: true,
                googAutoGainControl: true,
                googHighpassFilter: true,
                googTypingNoiseDetection: true,
                googNoiseReduction: true,
              };
        }

        const stream = await navigator.mediaDevices.getUserMedia(constraints);

        // ÎßàÏù¥ÌÅ¨ Ï¥àÍ∏∞ ÏÑ§Ï†ï
        if (audio && stream.getAudioTracks().length > 0) {
          stream.getAudioTracks().forEach((track) => {
            track.enabled = defaultMicOn;
          });
        }

        setCurrentStream(stream);
        streamRef.current = stream;
        setLocalStream(stream);
        setVideoEnabled(video && stream.getVideoTracks().length > 0);
        setAudioEnabled(
          defaultMicOn && audio && stream.getAudioTracks().length > 0
        );
      } catch (err) {
        console.error('‚ùå ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§ Ïπ¥Î©îÎùº ÏãúÏûë Ïã§Ìå®:', err);
        setStreamError(err.message);
        throw err;
      } finally {
        setIsLoading(false);
        initializingRef.current = false;
      }
    },
    [
      isLoading,
      selectedDevices,
      defaultMicOn,
      setLocalStream,
      setVideoEnabled,
      setAudioEnabled,
    ]
  );

  const stopCamera = useCallback(() => {
    const streamToStop = streamRef.current;
    if (streamToStop) {
      streamToStop.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }

    setCurrentStream(null);
    setLocalStream(null);
    setVideoEnabled(false);
    setAudioEnabled(false);

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
  }, [setLocalStream, setVideoEnabled, setAudioEnabled]);

  const stopMic = useCallback(() => {
    const audioTrack = streamRef.current
      ?.getAudioTracks()
      .find((t) => t.kind === 'audio');

    if (audioTrack) {
      streamRef.current?.removeTrack(audioTrack);
      audioTrack.stop();
      setAudioEnabled(false);
    }
  }, [setAudioEnabled]);

  /**
   * ÎßàÏù¥ÌÅ¨ ÏãúÏûë (ÌäπÏ†ï ÎîîÎ∞îÏù¥Ïä§ ÏßÄÏõê)
   */
  const startMic = useCallback(async () => {
    try {
      let audioDeviceId = selectedDevices.audioInput;

      if (!audioDeviceId && hasAudioDevices && devices.audioInputs.length > 0) {
        audioDeviceId = devices.audioInputs[0].deviceId;
      }

      const audioConstraints = {
        audio: audioDeviceId
          ? {
              deviceId: { exact: audioDeviceId },
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 1,
              latency: 0.01,
              volume: 0.8,
              // Í≥†Í∏â ÎÖ∏Ïù¥Ï¶à Ï≤òÎ¶¨
              googEchoCancellation: true,
              googNoiseSuppression: true,
              googAutoGainControl: true,
              googHighpassFilter: true,
              googTypingNoiseDetection: true,
              googNoiseReduction: true,
            }
          : {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              sampleRate: 48000,
              channelCount: 1,
              latency: 0.01,
              volume: 0.8,
              // Í≥†Í∏â ÎÖ∏Ïù¥Ï¶à Ï≤òÎ¶¨
              googEchoCancellation: true,
              googNoiseSuppression: true,
              googAutoGainControl: true,
              googHighpassFilter: true,
              googTypingNoiseDetection: true,
              googNoiseReduction: true,
            },
      };

      const newAudioStream =
        await navigator.mediaDevices.getUserMedia(audioConstraints);
      const newAudioTrack = newAudioStream.getAudioTracks()[0];

      if (newAudioTrack && streamRef.current) {
        streamRef.current.addTrack(newAudioTrack);
        setAudioEnabled(true);
      }
    } catch (err) {
      console.error('‚ùå ÎßàÏù¥ÌÅ¨ ÏãúÏûë Ïã§Ìå®:', err);
      setStreamError('ÎßàÏù¥ÌÅ¨Î•º ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
    }
  }, [selectedDevices.audioInput, setAudioEnabled, hasAudioDevices, devices]);

  const hardToggleCamera = useCallback(async () => {
    if (currentStream) {
      stopCamera();
    } else {
      await startCamera();
    }
  }, [currentStream, stopCamera, startCamera]);

  const hardToggleMic = useCallback(async () => {
    const audioTrack = streamRef.current
      ?.getAudioTracks()
      .find((t) => t.kind === 'audio');

    if (audioTrack && audioTrack.enabled) {
      stopMic();
    } else if (audioTrack && !audioTrack.enabled) {
      audioTrack.enabled = true;
      setAudioEnabled(true);
    } else {
      await startMic();
    }
  }, [stopMic, setAudioEnabled, startMic]);

  /**
   * üîß ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
   */
  const handleAudioDeviceChange = useCallback(
    async (deviceId) => {
      try {
        if (selectedDevices.audioInput === deviceId) {
          return; // ÎèôÏùºÌïú ÎîîÎ∞îÏù¥Ïä§Î©¥ Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå
        }

        await changeDevice('audioInput', deviceId);

        // ÌòÑÏû¨ Ïä§Ìä∏Î¶ºÏù¥ ÏûàÍ≥† Ïò§ÎîîÏò§Í∞Ä ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞ Ïû¨ÏãúÏûë
        if (currentStream && isAudioEnabled) {
          const wasVideoEnabled = isVideoEnabled;

          // Ïû†Ïãú Ï§ëÏßÄ
          stopCamera();

          // ÏÉà ÎîîÎ∞îÏù¥Ïä§Î°ú Ïû¨ÏãúÏûë
          setTimeout(async () => {
            await startCameraWithAudioDevice({
              audioDeviceId: deviceId,
              video: wasVideoEnabled,
              audio: true,
            });
          }, 300);
        }
      } catch (error) {
        console.error('‚ùå ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§ Î≥ÄÍ≤Ω Ïã§Ìå®:', error);
        setStreamError('ÎßàÏù¥ÌÅ¨ ÎîîÎ∞îÏù¥Ïä§ Î≥ÄÍ≤Ω Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      }
    },
    [
      changeDevice,
      selectedDevices.audioInput,
      currentStream,
      isAudioEnabled,
      isVideoEnabled,
      stopCamera,
      startCameraWithAudioDevice,
    ]
  );

  /**
   * Ïò§ÎîîÏò§ Ï∂úÎ†• ÏóòÎ¶¨Î®ºÌä∏ Îì±Î°ù (ÎπÑÎîîÏò§ ÏöîÏÜåÏö©)
   */
  const attachAudioOutput = useCallback(
    async (videoElement) => {
      if (!videoElement) return;

      try {
        registerAudioElement(videoElement);

        const outputDeviceId = selectedDevices.audioOutput;

        if (outputDeviceId && typeof videoElement.setSinkId === 'function') {
          await videoElement.setSinkId(outputDeviceId);
        }
      } catch (err) {
        console.error('üîá Ïò§ÎîîÏò§ Ï∂úÎ†• Ïû•Ïπò Î≥ÄÍ≤Ω Ïã§Ìå®:', err);
      }
    },
    [registerAudioElement, selectedDevices.audioOutput]
  );

  // ÏûêÎèô ÏãúÏûë Î°úÏßÅ
  useEffect(() => {
    if (
      autoStart &&
      !autoStartCompleted &&
      !currentStream &&
      !isLoading &&
      !initializingRef.current
    ) {
      if (permissions.isDenied) return;
      setAutoStartCompleted(true);

      startCamera().catch((error) => {
        console.warn('‚ùå ÏûêÎèô ÏãúÏûë Ïã§Ìå®:', error.message);
        setAutoStartCompleted(false);
      });
    }
  }, [
    autoStart,
    autoStartCompleted,
    currentStream,
    startCamera,
    isLoading,
    permissions.isDenied,
  ]);

  // ÎπÑÎîîÏò§ ÏöîÏÜåÏóê Ïä§Ìä∏Î¶º Ïó∞Í≤∞
  useEffect(() => {
    if (!currentStream || !videoRef.current) return;

    const video = videoRef.current;

    let timeoutId;

    const tryAttach = () => {
      // if (videoRef.current && videoRef.current !== video.srcObject) {
      if (video.srcObject !== currentStream) {
        videoRef.current.srcObject = currentStream;
        attachAudioOutput(videoRef.current);
      } else {
        requestAnimationFrame(tryAttach);
      }
    };

    tryAttach();
    timeoutId = setTimeout(tryAttach, 100);

    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [currentStream, attachAudioOutput]);

  // ‚úÖ Î™®Î∞îÏùºÏóêÏÑú Ïï±ÏùÑ ÎÇ¥Î¶¨Í±∞ÎÇò Ïû†Í∏à/ÌÉ≠ Ï†ÑÌôò Ïãú Ïä§Ìä∏Î¶ºÏùÑ ÏôÑÏ†ÑÌûà Ï¢ÖÎ£å
  useEffect(() => {
    const hardStop = () => {
      const s = streamRef.current;
      if (!s) return;

      try {
        s.getTracks().forEach((t) => {
          try {
            t.stop();
          } catch {}
        });
      } finally {
        streamRef.current = null;
        setCurrentStream(null);
        setLocalStream(null);
        setVideoEnabled(false);
        setAudioEnabled(false);
        if (videoRef.current) {
          videoRef.current.srcObject = null;
        }
        // console.log('üõë Î∞±Í∑∏ÎùºÏö¥Îìú/Ïû†Í∏à Í∞êÏßÄ ‚Üí Ïä§Ìä∏Î¶º ÏôÑÏ†Ñ Ï¢ÖÎ£å');
      }
    };

    // Î¨∏ÏÑúÍ∞Ä Ïà®Í≤®Ïßà Îïå(iOS/Android Ïû†Í∏à, Ïï± Ï†ÑÌôò Ìè¨Ìï®) Î∞îÎ°ú Ï¢ÖÎ£å
    const onVisibility = () => {
      if (document.hidden) hardStop();
    };

    // ÌéòÏù¥ÏßÄÍ∞Ä Ïà®ÍπÄ ÏÉÅÌÉúÎ°ú Ï†ÑÌôòÎê† Îïå(bfcache ÏßÑÏûÖ Îì±)ÎèÑ Ï¢ÖÎ£å
    const onPageHide = () => {
      hardStop();
    };

    // ÌÉ≠/Ï∞Ω Îã´Ìûò ÏßÅÏ†ÑÏóê Ï¢ÖÎ£å
    const onBeforeUnload = () => {
      hardStop();
    };

    document.addEventListener('visibilitychange', onVisibility);
    window.addEventListener('pagehide', onPageHide);
    window.addEventListener('beforeunload', onBeforeUnload);

    return () => {
      document.removeEventListener('visibilitychange', onVisibility);
      window.removeEventListener('pagehide', onPageHide);
      window.removeEventListener('beforeunload', onBeforeUnload);
    };
  }, [setLocalStream, setVideoEnabled, setAudioEnabled]);

  // useEffect(() => {
  //   if (!currentStream || !videoRef.current) return;
  //   const video = videoRef.current;

  //   const attach = async () => {
  //     // ‚úÖ Ïò¨Î∞îÎ•∏ ÎπÑÍµê
  //     if (video.srcObject !== currentStream) {
  //       video.srcObject = currentStream;
  //     }
  //     // ‚úÖ ÏïàÎìú/Î™®Î∞îÏùºÏóêÏÑú Ïû¨ÏÉù Î≥¥Ïû•
  //     try {
  //       await video.play();
  //     } catch (e) {
  //       console.warn(
  //         'video.play() failed (will retry on user gesture):',
  //         e?.message
  //       );
  //     }
  //     // (ÌïÑÏöîÏãú) Ïò§ÎîîÏò§ Ï∂úÎ†• Ïó∞Í≤∞ Ïú†ÏßÄ
  //     attachAudioOutput?.(video);
  //   };

  //   attach();
  // }, [currentStream, attachAudioOutput]);

  // ÏóêÎü¨ ÏÉÅÌÉú ÌÜµÌï©
  const combinedError = streamError || deviceError;

  return {
    // Í∏∞Î≥∏ Í∏∞Îä•
    videoRef,
    currentStream,
    isLoading: isLoading || devicesLoading,
    error: combinedError,

    // Ïπ¥Î©îÎùº Ï†úÏñ¥
    startCamera,
    stopCamera,
    startMic,
    stopMic,
    hardToggleCamera,
    hardToggleMic,

    // ÎßàÏù¥ÌÅ¨ ÏûÖÎ†• Î∞è Ïò§ÎîîÏò§ Ï∂úÎ†• ÎîîÎ∞îÏù¥Ïä§ Í¥ÄÎ¶¨
    devices: {
      audioInputs: devices.audioInputs, // ÎßàÏù¥ÌÅ¨ ÏûÖÎ†•
      audioOutputs: devices.audioOutputs, // Ïò§ÎîîÏò§ Ï∂úÎ†•
    },
    selectedDevices: {
      audioInput: selectedDevices.audioInput, // ÎßàÏù¥ÌÅ¨ ÏûÖÎ†•
      audioOutput: selectedDevices.audioOutput, // Ïò§ÎîîÏò§ Ï∂úÎ†•
    },
    selectAudioDevice,
    selectOutputDevice,
    handleAudioDeviceChange,
    getCurrentDeviceInfo,
    attachAudioOutput,

    permissions: {
      loading: permissions.loading,
      state: permissions.state,
      isDenied: permissions.isDenied,
      isPrompt: permissions.isPrompt,
      isGranted: permissions.isGranted,
      requestBoth: permissions.requestBoth,
      refresh: permissions.refresh,
      platformHelp: permissions.platformHelp,
    },

    // ÏÉÅÌÉú
    hasAudioDevices,
    support,

    // Í≥†Í∏â Í∏∞Îä•
    startCameraWithAudioDevice,

    // ÏÉÅÌÉú ÌôïÏù∏
    isReady: hasAudioDevices && !isLoading,
    canStart: hasAudioDevices && !isLoading,
    isActive: !!currentStream,
    autoStartCompleted,
  };
}
